{"message":"type annotations needed","code":{"code":"E0283","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0283\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nWe can see a self-contained example below:\n\n```compile_fail,E0283\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\nThis error can be solved by adding type annotations that provide the missing\ninformation to the compiler. In this case, the solution is to specify the\ntrait's type parameter:\n\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n"},"level":"error","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":2687,"byte_end":2691,"line_start":90,"line_end":90,"column_start":79,"column_end":83,"is_primary":true,"text":[{"text":"            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":79,"highlight_end":83}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"cannot satisfy `_: From<T>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `T` to implement `Into<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try using a fully qualified path to specify the expected types","code":null,"level":"help","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":2681,"byte_end":2681,"line_start":90,"line_end":90,"column_start":73,"column_end":73,"is_primary":true,"text":[{"text":"            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":73,"highlight_end":73}],"label":null,"suggested_replacement":"<T as Into<T>>::into(","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":2686,"byte_end":2693,"line_start":90,"line_end":90,"column_start":78,"column_end":85,"is_primary":true,"text":[{"text":"            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":78,"highlight_end":85}],"label":null,"suggested_replacement":")","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0283]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs:90:79\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: cannot satisfy `_: From<T>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `T` to implement `Into<_>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try using a fully qualified path to specify the expected types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || \u001b[0m\u001b[0m\u001b[38;5;10m<T as Into<T>>::into(\u001b[0m\u001b[0mvalue\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\u001b[0m >= 9 {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                         \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[38;5;10m~\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0283","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0283\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nWe can see a self-contained example below:\n\n```compile_fail,E0283\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\nThis error can be solved by adding type annotations that provide the missing\ninformation to the compiler. In this case, the solution is to specify the\ntrait's type parameter:\n\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n"},"level":"error","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":2694,"byte_end":2696,"line_start":90,"line_end":90,"column_start":86,"column_end":88,"is_primary":false,"text":[{"text":"            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":86,"highlight_end":88}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":2687,"byte_end":2691,"line_start":90,"line_end":90,"column_start":79,"column_end":83,"is_primary":true,"text":[{"text":"            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":79,"highlight_end":83}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"multiple `impl`s or `where` clauses satisfying `_: PartialOrd<i32>` found","code":null,"level":"note","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":273,"byte_end":288,"line_start":10,"line_end":10,"column_start":81,"column_end":96,"is_primary":true,"text":[{"text":"impl<T> Array2<T> where T: Clone + Default + PartialEq + Sub<i32, Output = T> + PartialOrd<i32> {","highlight_start":81,"highlight_end":96}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"and another `impl` found in the `core` crate: `impl PartialOrd for i32;`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try using a fully qualified path to specify the expected types","code":null,"level":"help","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":2681,"byte_end":2681,"line_start":90,"line_end":90,"column_start":73,"column_end":73,"is_primary":true,"text":[{"text":"            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":73,"highlight_end":73}],"label":null,"suggested_replacement":"<T as Into<T>>::into(","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":2686,"byte_end":2693,"line_start":90,"line_end":90,"column_start":78,"column_end":85,"is_primary":true,"text":[{"text":"            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":78,"highlight_end":85}],"label":null,"suggested_replacement":")","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0283]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs:90:79\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtype must be known at this point\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: multiple `impl`s or `where` clauses satisfying `_: PartialOrd<i32>` found\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs:10:81\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<T> Array2<T> where T: Clone + Default + PartialEq + Sub<i32, Output = T> + PartialOrd<i32> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: and another `impl` found in the `core` crate: `impl PartialOrd for i32;`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try using a fully qualified path to specify the expected types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || \u001b[0m\u001b[0m\u001b[38;5;10m<T as Into<T>>::into(\u001b[0m\u001b[0mvalue\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\u001b[0m >= 9 {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                         \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[38;5;10m~\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0283","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0283\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nWe can see a self-contained example below:\n\n```compile_fail,E0283\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\nThis error can be solved by adding type annotations that provide the missing\ninformation to the compiler. In this case, the solution is to specify the\ntrait's type parameter:\n\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n"},"level":"error","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":2784,"byte_end":2785,"line_start":93,"line_end":93,"column_start":40,"column_end":41,"is_primary":true,"text":[{"text":"            if frequency[value.into()] > 0 {","highlight_start":40,"highlight_end":41}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"multiple `impl`s or `where` clauses satisfying `_: PartialOrd<i32>` found","code":null,"level":"note","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":273,"byte_end":288,"line_start":10,"line_end":10,"column_start":81,"column_end":96,"is_primary":true,"text":[{"text":"impl<T> Array2<T> where T: Clone + Default + PartialEq + Sub<i32, Output = T> + PartialOrd<i32> {","highlight_start":81,"highlight_end":96}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"and another `impl` found in the `core` crate: `impl PartialOrd for i32;`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0283]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs:93:40\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if frequency[value.into()] > 0 {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: multiple `impl`s or `where` clauses satisfying `_: PartialOrd<i32>` found\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs:10:81\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<T> Array2<T> where T: Clone + Default + PartialEq + Sub<i32, Output = T> + PartialOrd<i32> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: and another `impl` found in the `core` crate: `impl PartialOrd for i32;`\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0283","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0283\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nWe can see a self-contained example below:\n\n```compile_fail,E0283\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\nThis error can be solved by adding type annotations that provide the missing\ninformation to the compiler. In this case, the solution is to specify the\ntrait's type parameter:\n\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n"},"level":"error","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":3169,"byte_end":3173,"line_start":105,"line_end":105,"column_start":79,"column_end":83,"is_primary":true,"text":[{"text":"            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":79,"highlight_end":83}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"cannot satisfy `_: From<T>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `T` to implement `Into<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try using a fully qualified path to specify the expected types","code":null,"level":"help","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":3163,"byte_end":3163,"line_start":105,"line_end":105,"column_start":73,"column_end":73,"is_primary":true,"text":[{"text":"            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":73,"highlight_end":73}],"label":null,"suggested_replacement":"<T as Into<T>>::into(","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":3168,"byte_end":3175,"line_start":105,"line_end":105,"column_start":78,"column_end":85,"is_primary":true,"text":[{"text":"            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":78,"highlight_end":85}],"label":null,"suggested_replacement":")","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0283]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs:105:79\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m105\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: cannot satisfy `_: From<T>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `T` to implement `Into<_>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try using a fully qualified path to specify the expected types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m105\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || \u001b[0m\u001b[0m\u001b[38;5;10m<T as Into<T>>::into(\u001b[0m\u001b[0mvalue\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\u001b[0m >= 9 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                         \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[38;5;10m~\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0283","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0283\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nWe can see a self-contained example below:\n\n```compile_fail,E0283\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\nThis error can be solved by adding type annotations that provide the missing\ninformation to the compiler. In this case, the solution is to specify the\ntrait's type parameter:\n\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n"},"level":"error","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":3176,"byte_end":3178,"line_start":105,"line_end":105,"column_start":86,"column_end":88,"is_primary":false,"text":[{"text":"            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":86,"highlight_end":88}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":3169,"byte_end":3173,"line_start":105,"line_end":105,"column_start":79,"column_end":83,"is_primary":true,"text":[{"text":"            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":79,"highlight_end":83}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"multiple `impl`s or `where` clauses satisfying `_: PartialOrd<i32>` found","code":null,"level":"note","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":273,"byte_end":288,"line_start":10,"line_end":10,"column_start":81,"column_end":96,"is_primary":true,"text":[{"text":"impl<T> Array2<T> where T: Clone + Default + PartialEq + Sub<i32, Output = T> + PartialOrd<i32> {","highlight_start":81,"highlight_end":96}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"and another `impl` found in the `core` crate: `impl PartialOrd for i32;`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try using a fully qualified path to specify the expected types","code":null,"level":"help","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":3163,"byte_end":3163,"line_start":105,"line_end":105,"column_start":73,"column_end":73,"is_primary":true,"text":[{"text":"            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":73,"highlight_end":73}],"label":null,"suggested_replacement":"<T as Into<T>>::into(","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":3168,"byte_end":3175,"line_start":105,"line_end":105,"column_start":78,"column_end":85,"is_primary":true,"text":[{"text":"            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":78,"highlight_end":85}],"label":null,"suggested_replacement":")","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0283]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs:105:79\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m105\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtype must be known at this point\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: multiple `impl`s or `where` clauses satisfying `_: PartialOrd<i32>` found\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs:10:81\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<T> Array2<T> where T: Clone + Default + PartialEq + Sub<i32, Output = T> + PartialOrd<i32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: and another `impl` found in the `core` crate: `impl PartialOrd for i32;`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try using a fully qualified path to specify the expected types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m105\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || \u001b[0m\u001b[0m\u001b[38;5;10m<T as Into<T>>::into(\u001b[0m\u001b[0mvalue\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\u001b[0m >= 9 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                         \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[38;5;10m~\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0283","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0283\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nWe can see a self-contained example below:\n\n```compile_fail,E0283\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\nThis error can be solved by adding type annotations that provide the missing\ninformation to the compiler. In this case, the solution is to specify the\ntrait's type parameter:\n\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n"},"level":"error","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":3266,"byte_end":3267,"line_start":108,"line_end":108,"column_start":40,"column_end":41,"is_primary":true,"text":[{"text":"            if frequency[value.into()] > 0 {","highlight_start":40,"highlight_end":41}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"multiple `impl`s or `where` clauses satisfying `_: PartialOrd<i32>` found","code":null,"level":"note","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":273,"byte_end":288,"line_start":10,"line_end":10,"column_start":81,"column_end":96,"is_primary":true,"text":[{"text":"impl<T> Array2<T> where T: Clone + Default + PartialEq + Sub<i32, Output = T> + PartialOrd<i32> {","highlight_start":81,"highlight_end":96}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"and another `impl` found in the `core` crate: `impl PartialOrd for i32;`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0283]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs:108:40\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if frequency[value.into()] > 0 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: multiple `impl`s or `where` clauses satisfying `_: PartialOrd<i32>` found\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs:10:81\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<T> Array2<T> where T: Clone + Default + PartialEq + Sub<i32, Output = T> + PartialOrd<i32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: and another `impl` found in the `core` crate: `impl PartialOrd for i32;`\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0283","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0283\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nWe can see a self-contained example below:\n\n```compile_fail,E0283\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\nThis error can be solved by adding type annotations that provide the missing\ninformation to the compiler. In this case, the solution is to specify the\ntrait's type parameter:\n\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n"},"level":"error","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":4099,"byte_end":4103,"line_start":129,"line_end":129,"column_start":83,"column_end":87,"is_primary":true,"text":[{"text":"                if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":83,"highlight_end":87}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"cannot satisfy `_: From<T>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `T` to implement `Into<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try using a fully qualified path to specify the expected types","code":null,"level":"help","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":4093,"byte_end":4093,"line_start":129,"line_end":129,"column_start":77,"column_end":77,"is_primary":true,"text":[{"text":"                if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":77,"highlight_end":77}],"label":null,"suggested_replacement":"<T as Into<T>>::into(","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":4098,"byte_end":4105,"line_start":129,"line_end":129,"column_start":82,"column_end":89,"is_primary":true,"text":[{"text":"                if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":82,"highlight_end":89}],"label":null,"suggested_replacement":")","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0283]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs:129:83\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m129\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: cannot satisfy `_: From<T>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `T` to implement `Into<_>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try using a fully qualified path to specify the expected types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m129\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || \u001b[0m\u001b[0m\u001b[38;5;10m<T as Into<T>>::into(\u001b[0m\u001b[0mvalue\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\u001b[0m >= 9 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                             \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[38;5;10m~\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0283","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0283\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nWe can see a self-contained example below:\n\n```compile_fail,E0283\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\nThis error can be solved by adding type annotations that provide the missing\ninformation to the compiler. In this case, the solution is to specify the\ntrait's type parameter:\n\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n"},"level":"error","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":4106,"byte_end":4108,"line_start":129,"line_end":129,"column_start":90,"column_end":92,"is_primary":false,"text":[{"text":"                if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":90,"highlight_end":92}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":4099,"byte_end":4103,"line_start":129,"line_end":129,"column_start":83,"column_end":87,"is_primary":true,"text":[{"text":"                if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":83,"highlight_end":87}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"multiple `impl`s or `where` clauses satisfying `_: PartialOrd<i32>` found","code":null,"level":"note","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":273,"byte_end":288,"line_start":10,"line_end":10,"column_start":81,"column_end":96,"is_primary":true,"text":[{"text":"impl<T> Array2<T> where T: Clone + Default + PartialEq + Sub<i32, Output = T> + PartialOrd<i32> {","highlight_start":81,"highlight_end":96}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"and another `impl` found in the `core` crate: `impl PartialOrd for i32;`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try using a fully qualified path to specify the expected types","code":null,"level":"help","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":4093,"byte_end":4093,"line_start":129,"line_end":129,"column_start":77,"column_end":77,"is_primary":true,"text":[{"text":"                if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":77,"highlight_end":77}],"label":null,"suggested_replacement":"<T as Into<T>>::into(","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":4098,"byte_end":4105,"line_start":129,"line_end":129,"column_start":82,"column_end":89,"is_primary":true,"text":[{"text":"                if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {","highlight_start":82,"highlight_end":89}],"label":null,"suggested_replacement":")","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0283]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs:129:83\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m129\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || value.into() >= 9 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtype must be known at this point\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: multiple `impl`s or `where` clauses satisfying `_: PartialOrd<i32>` found\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs:10:81\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<T> Array2<T> where T: Clone + Default + PartialEq + Sub<i32, Output = T> + PartialOrd<i32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: and another `impl` found in the `core` crate: `impl PartialOrd for i32;`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try using a fully qualified path to specify the expected types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m129\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                if <<T as Sub<i32>>::Output as Into<T>>::into(value) < 0 || \u001b[0m\u001b[0m\u001b[38;5;10m<T as Into<T>>::into(\u001b[0m\u001b[0mvalue\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\u001b[0m >= 9 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                             \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[38;5;10m~\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0283","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0283\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nWe can see a self-contained example below:\n\n```compile_fail,E0283\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\nThis error can be solved by adding type annotations that provide the missing\ninformation to the compiler. In this case, the solution is to specify the\ntrait's type parameter:\n\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n"},"level":"error","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":4296,"byte_end":4297,"line_start":134,"line_end":134,"column_start":44,"column_end":45,"is_primary":true,"text":[{"text":"                if frequency[value.into()] > 0 {","highlight_start":44,"highlight_end":45}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"multiple `impl`s or `where` clauses satisfying `_: PartialOrd<i32>` found","code":null,"level":"note","spans":[{"file_name":"/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs","byte_start":273,"byte_end":288,"line_start":10,"line_end":10,"column_start":81,"column_end":96,"is_primary":true,"text":[{"text":"impl<T> Array2<T> where T: Clone + Default + PartialEq + Sub<i32, Output = T> + PartialOrd<i32> {","highlight_start":81,"highlight_end":96}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"and another `impl` found in the `core` crate: `impl PartialOrd for i32;`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0283]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs:134:44\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m134\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if frequency[value.into()] > 0 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: multiple `impl`s or `where` clauses satisfying `_: PartialOrd<i32>` found\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/mattboekamp/Desktop/csc411/CSC411/a2/array2/src/lib.rs:10:81\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<T> Array2<T> where T: Clone + Default + PartialEq + Sub<i32, Output = T> + PartialOrd<i32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: and another `impl` found in the `core` crate: `impl PartialOrd for i32;`\u001b[0m\n\n"}
{"message":"aborting due to 9 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 9 previous errors\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0283`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0283`.\u001b[0m\n"}
